
# Important enviornment variables to take note of:

# frontend vars:
#   STATIC_FRONTEND_PATH: this may or may not exist in the final built container. If it does, that means there is an availible 
#                         directory containing a compiled build for the frontend generated by npm run build, django will make a check
#                         and serve that app if it exists.
#   NODE_ENV: generated by node based off of (provided by node, you don't need to define this explicitly)
#   REACT_APP_BACKEND_ENDPOINT: defines where frontend requests should be sent

# backend vars:
#   SECRET_KEY:  the django secret key, this needs to be kept secret
#   DJANGO_ENV:  the current enviornment the app is in ("development"/"production")
#   DB_NAME:     the name of the database being connected to
#   DB_HOSTNAME: the name of the database host
#   DB_PORT:     which port the database will be running on (NOTE: standard to postgres is 5432)
#   DB_USERNAME: the database user
#   DB_PASSWORD: the database password

# example build/run of docker container to show how to work with env vars.

# https://blog.ploetzli.ch/2020/efficient-multi-stage-build-django-docker/
# https://lincolnloop.com/insights/using-setuppy-your-django-project/


# FROM python:3.9-slim-buster
# WORKDIR /app/api
# COPY . ./
# RUN pip install -r requirements.txt
# RUN ["chmod", "+x", "/app/api/startup.sh"]
# EXPOSE 8000
# ENTRYPOINT ["/app/api/startup.sh"]




FROM python:3.9-slim-buster AS base 
WORKDIR /app/api
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . ./



FROM base AS development 
RUN ["chmod", "+x", "/app/api/startup.sh"]
EXPOSE 8000
ENTRYPOINT ["/app/api/startup.sh"]


FROM base AS production 
ENV DJANGO_SETTINGS_MODULE
ENV PYTHONPATH=/app
RUN ["python3", "manage.py", "collectstatic", "--noinput"]
EXPOSE 8000
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "your_project.wsgi"]